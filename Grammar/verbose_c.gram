@subheader'''
import re
'''


# 根节点，固定为RootNode，为后续多模块准备
start[RootNode]: mod=module END { RootNode([mod], LOCATIONS)}

# 模块
module[ModuleNode]: sl=statement* { ModuleNode(sl, LOCATIONS) }

# 基本语句
statement:
    | independent_block
    | class_definition
    | macro_definition  
    | function_ret
    | function
    | var_decl
    | var_assign
    | if_statement
    | while_statement
    | for_statement
    | break_statement
    | continue_statement
    | expression_as_statement

# 宏
macro_definition[ASTNode]:
    | include_statement
    | define_statement

# 引入文件
include_statement[IncludeNode]:
    | mc=MACRO_CODE { IncludeNode(path=match.group(1), LOCATIONS) if (match := re.match(r'#\s*include\s+["<](.+)[">]', mc.string)) else None }

# 定义宏
define_statement[DefineNode]:
    | mc=MACRO_CODE { DefineNode(name=match.group(1), body=match.group(2), LOCATIONS) if (match := re.match(r'#\s*define\s+([a-zA-Z_]\w*)\s+(.*)', mc.string)) else None }

# 函数
function[FunctionNode]: t=type_name n=NAME '(' p=params? ')' '{' b=func_block '}' { FunctionNode(t, NameNode(n.string, LOCATIONS), p or [], {}, b, LOCATIONS) }
params[list[ParamNode]]: head=typed_param tail=(',' typed_param)* { [head] + [t[1] for t in tail] }
typed_param[ParamNode]: t=type_name n=NAME { ParamNode(t, NameNode(n.string, LOCATIONS), LOCATIONS) }

# 代码块
independent_block[BlockNode]: "{" b=func_block "}" { b }
func_block[BlockNode]: s=statement* { BlockNode(s or [], LOCATIONS) }

# 返回、中断、继续
function_ret[ReturnNode]: 'return' r=expr? ';' { ReturnNode(r, LOCATIONS) }
break_statement[BreakNode]: "break" ";" { BreakNode(LOCATIONS) }
continue_statement[ContinueNode]: "continue" ";" { ContinueNode(LOCATIONS) }

# 变量
var_decl[VarDeclNode]: t=type_name n=NAME v=('=' expr)? ';' { VarDeclNode(t, NameNode(n.string, LOCATIONS), v[1] if v else None, LOCATIONS) }
# for循环中使用的变量声明
for_var_decl[VarDeclNode]: t=type_name n=NAME v=('=' expr)? { VarDeclNode(t, NameNode(n.string, LOCATIONS), v[1] if v else None, LOCATIONS) }
var_assign[AssignmentNode]: n=member_expr '=' v=expr ';' { AssignmentNode(n, v, LOCATIONS) }
type_name[TypeNode]:
      | t1=(SOFT_KEYWORD | NAME) t2=(SOFT_KEYWORD | NAME) &(NAME) { TypeNode(NameNode(t1.string + " " + t2.string, LOCATIONS), LOCATIONS) }
      | t=(SOFT_KEYWORD | NAME) { TypeNode(NameNode(t.string, LOCATIONS), LOCATIONS) }

# 表达式作为语句
expression_as_statement[ExprStmtNode]: e=expr ';' { ExprStmtNode(e, LOCATIONS) }

# 表达式
expr:
    | assignment
assignment[ASTNode]:
    | target=member_expr '=' val=assignment { AssignmentNode(target, val, LOCATIONS) }
    | logical_or
logical_or:
    | logical_or '||' logical_and { BinaryOpNode(logical_or, Operator.LOGICAL_OR, logical_and, LOCATIONS) }
    | logical_and
logical_and:
    | logical_and '&&' equality { BinaryOpNode(logical_and, Operator.LOGICAL_AND, equality, LOCATIONS) }
    | equality
equality:
    | equality '==' relational { BinaryOpNode(equality, Operator.EQUAL, relational, LOCATIONS) }
    | equality '!=' relational { BinaryOpNode(equality, Operator.NOT_EQUAL, relational, LOCATIONS) }
    | relational
relational:
    | relational '<' additive { BinaryOpNode(relational, Operator.LESS_THAN, additive, LOCATIONS) }
    | relational '<=' additive { BinaryOpNode(relational, Operator.LESS_EQUAL, additive, LOCATIONS) }
    | relational '>' additive { BinaryOpNode(relational, Operator.GREATER_THAN, additive, LOCATIONS) }
    | relational '>=' additive { BinaryOpNode(relational, Operator.GREATER_EQUAL, additive, LOCATIONS) }
    | additive
additive:
    | additive '+' multiplicative { BinaryOpNode(additive, Operator.ADD, multiplicative, LOCATIONS) }
    | additive '-' multiplicative { BinaryOpNode(additive, Operator.SUBTRACT, multiplicative, LOCATIONS) }
    | multiplicative
multiplicative:
    | multiplicative '*' factor { BinaryOpNode(multiplicative, Operator.MULTIPLY, factor, LOCATIONS) }
    | multiplicative '/' factor { BinaryOpNode(multiplicative, Operator.DIVIDE, factor, LOCATIONS) }
    | factor

factor:
    | '(' expr ')' { expr }
    | unary
    | new_instance
    | member_expr
unary:
    | '-' factor { UnaryOpNode(Operator.SUBTRACT, factor, LOCATIONS) }
    | '+' factor { UnaryOpNode(Operator.ADD, factor, LOCATIONS) }
    | '!' factor { UnaryOpNode(Operator.NOT, factor, LOCATIONS) }

member_expr:
    | member_expr '.' property=NAME { GetPropertyNode(member_expr, NameNode(property.string, LOCATIONS), LOCATIONS) }
    | member_expr '(' args=func_call_param? ')' { CallNode(member_expr, args or [], {}, LOCATIONS) }
    | atom
func_call_param[list[ASTNode]]: head=expr tail=(',' expr)* { [head] + [t[1] for t in tail] }

atom:
    | b=('true' | 'false') { BoolNode(b.string, LOCATIONS) }
    | 'null' { NullNode(LOCATIONS) }
    | NAME { NameNode(name.string, LOCATIONS) }
    | NUMBER { NumberNode(number.string, LOCATIONS) }
    | STRING { StringNode(string.string, LOCATIONS) }

# 控制流语句
if_statement[IfNode]: 'if' '(' c=expr ')' '{' tb=func_block '}' e=else_clause? { IfNode(c, tb, e, LOCATIONS) }
else_clause[ASTNode]:
    | 'else' b=if_statement { b }
    | 'else' '{' b=func_block '}' { b }

while_statement[WhileNode]: 'while' '(' c=expr ')' '{' b=func_block '}' { WhileNode(c, b, LOCATIONS) }
for_statement[ForNode]: 'for' '(' i=(for_var_decl | expr)? ';' c=expr? ';' u=expr? ')' '{' b=func_block '}' { ForNode(i, c, u, b, LOCATIONS) }

# 类与对象
class_definition[ClassNode]: "class" n=NAME "{" cb=class_body "}" { ClassNode(NameNode(n.string, LOCATIONS), cb, [], LOCATIONS) }
class_body[BlockNode]: m=(var_decl | function)* { BlockNode(m or [], LOCATIONS) }
new_instance[NewInstanceNode]: 'new' c=member_expr { NewInstanceNode(c, LOCATIONS) }
