start: function

# 包导入
pack_import: "#"? "include" n=include_name { PackImportNode(n,LOCATIONS) }
# TODO 结构优化

include_name[NameNode]:
      | i=INCLUDE_HEADER { NameNode(i.string,LOCATIONS) }
      | s=STRING { StringNode(s.string,LOCATIONS) }
      | n=NAME { NameNode(n.string,LOCATIONS) }

# 函数定义
function: a=return_type b=function_name "(" c=param? ")" "{" fb=func_block* "}" {FunctionNode(a,b,c,None,fb,LOCATIONS)}

return_type[NameNode]: NAME { NameNode(name.string,LOCATIONS) }
function_name[NameNode]: NAME { NameNode(name.string,LOCATIONS) }
param[List[ParamNode]]: p1=typed_param p2=("," typed_param)* { [p1] + ([item[1] for item in p2] if p2 else []) }
typed_param[ParamNode]: t=NAME n=NAME { ParamNode(t.string, n.string,LOCATIONS) }

# 函数体
func_block[ASTNode]:
      | function_ret
      | pack_import
      | function
      | var_decl
      | var_assign
      | if_statement
      | expression_as_statement # 表达式语句 (包括函数调用语句)

# 函数返回
function_ret[ReturnNode]: "return" r=expr ";"? { ReturnNode(r,LOCATIONS) }

# 函数调用
function_call: f=function_call_expr ";"? {f}
function_call_expr[CallNode]: n=function_name "(" a=func_call_param? ")" { CallNode(n,a,LOCATIONS) }
# TODO 增加链式调用

func_call_param[List[ASTNode]]: e1=expr e2=("," expr)* { [e1] + ([item[1] for item in e2] if e2 else []) }

# 变量声明
var_decl: t=type_name n=var_name v=( "=" var_value )? ";"? { VarDeclNode(t,n,v[1] if v else None,LOCATIONS) }
# TODO 增加多变量声明支持

type_name: NAME { NameNode(name.string,LOCATIONS) }
var_name: NAME { NameNode(name.string,LOCATIONS) }
var_value: expr

# 变量赋值
var_assign: n=var_name "=" v=var_value ";"? { AssignmentNode(n,v,LOCATIONS) }

# 表达式作为语句
expression_as_statement[ASTNode]: e=expr ";"? { e }

# 比较运算
comparison:
      | comparison "==" logical_and { BinaryOpNode(comparison, Operator.EQUAL, logical_and,LOCATIONS) }
      | comparison "!=" logical_and { BinaryOpNode(comparison, Operator.NOT_EQUAL, logical_and,LOCATIONS) }
      | comparison "<" logical_and { BinaryOpNode(comparison, Operator.LESS_THAN, logical_and,LOCATIONS) }
      | comparison "<=" logical_and { BinaryOpNode(comparison, Operator.LESS_EQUAL, logical_and,LOCATIONS) }
      | comparison ">" logical_and { BinaryOpNode(comparison, Operator.GREATER_THAN, logical_and,LOCATIONS) }
      | comparison ">=" logical_and { BinaryOpNode(comparison, Operator.GREATER_EQUAL, logical_and,LOCATIONS) }
      | logical_and { logical_and }

# 逻辑与运算
logical_and:
      | logical_and "&&" logical_or { BinaryOpNode(logical_and, Operator.LOGICAL_AND, logical_or,LOCATIONS) }
      | logical_or { logical_or }

# 逻辑或运算
logical_or:
      | logical_or "||" expr { BinaryOpNode(logical_or, Operator.LOGICAL_OR, expr,LOCATIONS) }
      | expr { expr }

# 四则运算
expr: 
      | expr '+' term { BinaryOpNode(expr, Operator.ADD, term,LOCATIONS) }
      | expr '-' term { BinaryOpNode(expr, Operator.SUBTRACT, term,LOCATIONS) }
      | term { term }

term: 
      | l=term '*' r=factor { BinaryOpNode(l, Operator.MULTIPLY, r,LOCATIONS) }
      | term '/' factor { BinaryOpNode(term, Operator.DIVIDE, factor,LOCATIONS) }
      | factor { factor }

factor:
      | '(' expr ')' { expr }
      | atom { atom }

atom:
      | function_call_expr
      | b=("true"|"false") { BoolNode(b,LOCATIONS) }
      | "null" { NullNode(LOCATIONS) }
      | NAME { NameNode(name.string,LOCATIONS) }
      | NUMBER { NumberNode(number.string,LOCATIONS) }
      | STRING { StringNode(string.string,LOCATIONS) }
